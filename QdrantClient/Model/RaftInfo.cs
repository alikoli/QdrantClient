/* 
 * Qdrant API
 *
 * API description for Qdrant vector search engine.  This document describes CRUD and search operations on collections of points (vectors with payload).  Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account. ## Examples This examples cover the most basic use-cases - collection creation and basic vector search. ### Create collection First - let's create a collection with dot-production metric. ``` curl -X PUT 'http://localhost:6333/collections/test_collection' \\   -H 'Content-Type: application/json' \\   - -data-raw '{     \"vectors\": {       \"size\": 4,       \"distance\": \"Dot\"     }   }'  ``` Expected response: ``` {     \"result\": true,     \"status\": \"ok\",     \"time\": 0.031095451 } ``` We can ensure that collection was created: ``` curl 'http://localhost:6333/collections/test_collection' ``` Expected response: ``` {   \"result\": {     \"status\": \"green\",     \"vectors_count\": 0,     \"segments_count\": 5,     \"disk_data_size\": 0,     \"ram_data_size\": 0,     \"config\": {       \"params\": {         \"vectors\": {           \"size\": 4,           \"distance\": \"Dot\"         }       },       \"hnsw_config\": {         \"m\": 16,         \"ef_construct\": 100,         \"full_scan_threshold\": 10000       },       \"optimizer_config\": {         \"deleted_threshold\": 0.2,         \"vacuum_min_vector_number\": 1000,         \"max_segment_number\": 5,         \"memmap_threshold\": 50000,         \"indexing_threshold\": 20000,         \"flush_interval_sec\": 1       },       \"wal_config\": {         \"wal_capacity_mb\": 32,         \"wal_segments_ahead\": 0       }     }   },   \"status\": \"ok\",   \"time\": 2.1199e-05 } ```  ### Add points Let's now add vectors with some payload: ``` curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \\ -H 'Content-Type: application/json' \\ - -data-raw '{   \"points\": [     {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},     {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},     {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},     {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},     {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},     {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}   ] }' ``` Expected response: ``` {     \"result\": {         \"operation_id\": 0,         \"status\": \"completed\"     },     \"status\": \"ok\",     \"time\": 0.000206061 } ``` ### Search with filtering Let's start with a basic request: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ - -data-raw '{     \"vector\": [0.2,0.1,0.9,0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },         { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000055785 } ``` But result is different if we add a filter: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ - -data-raw '{     \"filter\": {         \"should\": [             {                 \"key\": \"city\",                 \"match\": {                     \"value\": \"London\"                 }             }         ]     },     \"vector\": [0.2, 0.1, 0.9, 0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000093972 } ``` 
 *
 * OpenAPI spec version: v1.1.3
 * Contact: andrey@vasnetsov.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;
namespace IO.Swagger.Model
{
    /// <summary>
    /// Summary information about the current raft state
    /// </summary>
    [DataContract]
        public partial class RaftInfo :  IEquatable<RaftInfo>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="RaftInfo" /> class.
        /// </summary>
        /// <param name="term">Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication. (required).</param>
        /// <param name="commit">The index of the latest committed (finalized) operation that this peer is aware of. (required).</param>
        /// <param name="pendingOperations">Number of consensus operations pending to be applied on this peer (required).</param>
        /// <param name="leader">Leader of the current term.</param>
        /// <param name="role">Role of this peer in the current term.</param>
        /// <param name="isVoter">Is this peer a voter or a learner (required).</param>
        public RaftInfo(int? term = default(int?), int? commit = default(int?), int? pendingOperations = default(int?), int? leader = default(int?), AnyOfRaftInfoRole role = default(AnyOfRaftInfoRole), bool? isVoter = default(bool?))
        {
            // to ensure "term" is required (not null)
            if (term == null)
            {
                throw new InvalidDataException("term is a required property for RaftInfo and cannot be null");
            }
            else
            {
                this.Term = term;
            }
            // to ensure "commit" is required (not null)
            if (commit == null)
            {
                throw new InvalidDataException("commit is a required property for RaftInfo and cannot be null");
            }
            else
            {
                this.Commit = commit;
            }
            // to ensure "pendingOperations" is required (not null)
            if (pendingOperations == null)
            {
                throw new InvalidDataException("pendingOperations is a required property for RaftInfo and cannot be null");
            }
            else
            {
                this.PendingOperations = pendingOperations;
            }
            // to ensure "isVoter" is required (not null)
            if (isVoter == null)
            {
                throw new InvalidDataException("isVoter is a required property for RaftInfo and cannot be null");
            }
            else
            {
                this.IsVoter = isVoter;
            }
            this.Leader = leader;
            this.Role = role;
        }
        
        /// <summary>
        /// Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication.
        /// </summary>
        /// <value>Raft divides time into terms of arbitrary length, each beginning with an election. If a candidate wins the election, it remains the leader for the rest of the term. The term number increases monotonically. Each server stores the current term number which is also exchanged in every communication.</value>
        [DataMember(Name="term", EmitDefaultValue=false)]
        public int? Term { get; set; }

        /// <summary>
        /// The index of the latest committed (finalized) operation that this peer is aware of.
        /// </summary>
        /// <value>The index of the latest committed (finalized) operation that this peer is aware of.</value>
        [DataMember(Name="commit", EmitDefaultValue=false)]
        public int? Commit { get; set; }

        /// <summary>
        /// Number of consensus operations pending to be applied on this peer
        /// </summary>
        /// <value>Number of consensus operations pending to be applied on this peer</value>
        [DataMember(Name="pending_operations", EmitDefaultValue=false)]
        public int? PendingOperations { get; set; }

        /// <summary>
        /// Leader of the current term
        /// </summary>
        /// <value>Leader of the current term</value>
        [DataMember(Name="leader", EmitDefaultValue=false)]
        public int? Leader { get; set; }

        /// <summary>
        /// Role of this peer in the current term
        /// </summary>
        /// <value>Role of this peer in the current term</value>
        [DataMember(Name="role", EmitDefaultValue=false)]
        public AnyOfRaftInfoRole Role { get; set; }

        /// <summary>
        /// Is this peer a voter or a learner
        /// </summary>
        /// <value>Is this peer a voter or a learner</value>
        [DataMember(Name="is_voter", EmitDefaultValue=false)]
        public bool? IsVoter { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class RaftInfo {\n");
            sb.Append("  Term: ").Append(Term).Append("\n");
            sb.Append("  Commit: ").Append(Commit).Append("\n");
            sb.Append("  PendingOperations: ").Append(PendingOperations).Append("\n");
            sb.Append("  Leader: ").Append(Leader).Append("\n");
            sb.Append("  Role: ").Append(Role).Append("\n");
            sb.Append("  IsVoter: ").Append(IsVoter).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as RaftInfo);
        }

        /// <summary>
        /// Returns true if RaftInfo instances are equal
        /// </summary>
        /// <param name="input">Instance of RaftInfo to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(RaftInfo input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Term == input.Term ||
                    (this.Term != null &&
                    this.Term.Equals(input.Term))
                ) && 
                (
                    this.Commit == input.Commit ||
                    (this.Commit != null &&
                    this.Commit.Equals(input.Commit))
                ) && 
                (
                    this.PendingOperations == input.PendingOperations ||
                    (this.PendingOperations != null &&
                    this.PendingOperations.Equals(input.PendingOperations))
                ) && 
                (
                    this.Leader == input.Leader ||
                    (this.Leader != null &&
                    this.Leader.Equals(input.Leader))
                ) && 
                (
                    this.Role == input.Role ||
                    (this.Role != null &&
                    this.Role.Equals(input.Role))
                ) && 
                (
                    this.IsVoter == input.IsVoter ||
                    (this.IsVoter != null &&
                    this.IsVoter.Equals(input.IsVoter))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Term != null)
                    hashCode = hashCode * 59 + this.Term.GetHashCode();
                if (this.Commit != null)
                    hashCode = hashCode * 59 + this.Commit.GetHashCode();
                if (this.PendingOperations != null)
                    hashCode = hashCode * 59 + this.PendingOperations.GetHashCode();
                if (this.Leader != null)
                    hashCode = hashCode * 59 + this.Leader.GetHashCode();
                if (this.Role != null)
                    hashCode = hashCode * 59 + this.Role.GetHashCode();
                if (this.IsVoter != null)
                    hashCode = hashCode * 59 + this.IsVoter.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
