/* 
 * Qdrant API
 *
 * API description for Qdrant vector search engine.  This document describes CRUD and search operations on collections of points (vectors with payload).  Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account. ## Examples This examples cover the most basic use-cases - collection creation and basic vector search. ### Create collection First - let's create a collection with dot-production metric. ``` curl -X PUT 'http://localhost:6333/collections/test_collection' \\   -H 'Content-Type: application/json' \\   - -data-raw '{     \"vectors\": {       \"size\": 4,       \"distance\": \"Dot\"     }   }'  ``` Expected response: ``` {     \"result\": true,     \"status\": \"ok\",     \"time\": 0.031095451 } ``` We can ensure that collection was created: ``` curl 'http://localhost:6333/collections/test_collection' ``` Expected response: ``` {   \"result\": {     \"status\": \"green\",     \"vectors_count\": 0,     \"segments_count\": 5,     \"disk_data_size\": 0,     \"ram_data_size\": 0,     \"config\": {       \"params\": {         \"vectors\": {           \"size\": 4,           \"distance\": \"Dot\"         }       },       \"hnsw_config\": {         \"m\": 16,         \"ef_construct\": 100,         \"full_scan_threshold\": 10000       },       \"optimizer_config\": {         \"deleted_threshold\": 0.2,         \"vacuum_min_vector_number\": 1000,         \"max_segment_number\": 5,         \"memmap_threshold\": 50000,         \"indexing_threshold\": 20000,         \"flush_interval_sec\": 1       },       \"wal_config\": {         \"wal_capacity_mb\": 32,         \"wal_segments_ahead\": 0       }     }   },   \"status\": \"ok\",   \"time\": 2.1199e-05 } ```  ### Add points Let's now add vectors with some payload: ``` curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \\ -H 'Content-Type: application/json' \\ - -data-raw '{   \"points\": [     {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},     {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},     {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},     {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},     {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},     {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}   ] }' ``` Expected response: ``` {     \"result\": {         \"operation_id\": 0,         \"status\": \"completed\"     },     \"status\": \"ok\",     \"time\": 0.000206061 } ``` ### Search with filtering Let's start with a basic request: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ - -data-raw '{     \"vector\": [0.2,0.1,0.9,0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },         { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000055785 } ``` But result is different if we add a filter: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ - -data-raw '{     \"filter\": {         \"should\": [             {                 \"key\": \"city\",                 \"match\": {                     \"value\": \"London\"                 }             }         ]     },     \"vector\": [0.2, 0.1, 0.9, 0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000093972 } ``` 
 *
 * OpenAPI spec version: v1.1.3
 * Contact: andrey@vasnetsov.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface ICollectionsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Collection cluster info
        /// </summary>
        /// <remarks>
        /// Get cluster information for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>InlineResponse2007</returns>
        InlineResponse2007 CollectionClusterInfo (string collectionName);

        /// <summary>
        /// Collection cluster info
        /// </summary>
        /// <remarks>
        /// Get cluster information for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>ApiResponse of InlineResponse2007</returns>
        ApiResponse<InlineResponse2007> CollectionClusterInfoWithHttpInfo (string collectionName);
        /// <summary>
        /// Create collection
        /// </summary>
        /// <remarks>
        /// Create new collection with given parameters
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 CreateCollection (string collectionName, CreateCollection body = null, int? timeout = null);

        /// <summary>
        /// Create collection
        /// </summary>
        /// <remarks>
        /// Create new collection with given parameters
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> CreateCollectionWithHttpInfo (string collectionName, CreateCollection body = null, int? timeout = null);
        /// <summary>
        /// Create index for field in collection
        /// </summary>
        /// <remarks>
        /// Create index for field in collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 CreateFieldIndex (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);

        /// <summary>
        /// Create index for field in collection
        /// </summary>
        /// <remarks>
        /// Create index for field in collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> CreateFieldIndexWithHttpInfo (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);
        /// <summary>
        /// Create collection snapshot
        /// </summary>
        /// <remarks>
        /// Create new snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>InlineResponse20010</returns>
        InlineResponse20010 CreateSnapshot (string collectionName, bool? wait = null);

        /// <summary>
        /// Create collection snapshot
        /// </summary>
        /// <remarks>
        /// Create new snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>ApiResponse of InlineResponse20010</returns>
        ApiResponse<InlineResponse20010> CreateSnapshotWithHttpInfo (string collectionName, bool? wait = null);
        /// <summary>
        /// Delete collection
        /// </summary>
        /// <remarks>
        /// Drop collection and all associated data
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 DeleteCollection (string collectionName, int? timeout = null);

        /// <summary>
        /// Delete collection
        /// </summary>
        /// <remarks>
        /// Drop collection and all associated data
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> DeleteCollectionWithHttpInfo (string collectionName, int? timeout = null);
        /// <summary>
        /// Delete index for field in collection
        /// </summary>
        /// <remarks>
        /// Delete field index for collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 DeleteFieldIndex (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);

        /// <summary>
        /// Delete index for field in collection
        /// </summary>
        /// <remarks>
        /// Delete field index for collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> DeleteFieldIndexWithHttpInfo (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);
        /// <summary>
        /// Delete collection snapshot
        /// </summary>
        /// <remarks>
        /// Delete snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 DeleteSnapshot (string collectionName, string snapshotName, bool? wait = null);

        /// <summary>
        /// Delete collection snapshot
        /// </summary>
        /// <remarks>
        /// Delete snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> DeleteSnapshotWithHttpInfo (string collectionName, string snapshotName, bool? wait = null);
        /// <summary>
        /// Collection info
        /// </summary>
        /// <remarks>
        /// Get detailed information about specified existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>InlineResponse2005</returns>
        InlineResponse2005 GetCollection (string collectionName);

        /// <summary>
        /// Collection info
        /// </summary>
        /// <remarks>
        /// Get detailed information about specified existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>ApiResponse of InlineResponse2005</returns>
        ApiResponse<InlineResponse2005> GetCollectionWithHttpInfo (string collectionName);
        /// <summary>
        /// List aliases for collection
        /// </summary>
        /// <remarks>
        /// Get list of all aliases for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>InlineResponse2008</returns>
        InlineResponse2008 GetCollectionAliases (string collectionName);

        /// <summary>
        /// List aliases for collection
        /// </summary>
        /// <remarks>
        /// Get list of all aliases for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        ApiResponse<InlineResponse2008> GetCollectionAliasesWithHttpInfo (string collectionName);
        /// <summary>
        /// List collections
        /// </summary>
        /// <remarks>
        /// Get list name of all existing collections
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>InlineResponse2004</returns>
        InlineResponse2004 GetCollections ();

        /// <summary>
        /// List collections
        /// </summary>
        /// <remarks>
        /// Get list name of all existing collections
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of InlineResponse2004</returns>
        ApiResponse<InlineResponse2004> GetCollectionsWithHttpInfo ();
        /// <summary>
        /// List collections aliases
        /// </summary>
        /// <remarks>
        /// Get list of all existing collections aliases
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>InlineResponse2008</returns>
        InlineResponse2008 GetCollectionsAliases ();

        /// <summary>
        /// List collections aliases
        /// </summary>
        /// <remarks>
        /// Get list of all existing collections aliases
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        ApiResponse<InlineResponse2008> GetCollectionsAliasesWithHttpInfo ();
        /// <summary>
        /// Download collection snapshot
        /// </summary>
        /// <remarks>
        /// Download specified snapshot from a collection as a file
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>byte[]</returns>
        byte[] GetSnapshot (string collectionName, string snapshotName);

        /// <summary>
        /// Download collection snapshot
        /// </summary>
        /// <remarks>
        /// Download specified snapshot from a collection as a file
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>ApiResponse of byte[]</returns>
        ApiResponse<byte[]> GetSnapshotWithHttpInfo (string collectionName, string snapshotName);
        /// <summary>
        /// List collection snapshots
        /// </summary>
        /// <remarks>
        /// Get list of snapshots for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>InlineResponse2009</returns>
        InlineResponse2009 ListSnapshots (string collectionName);

        /// <summary>
        /// List collection snapshots
        /// </summary>
        /// <remarks>
        /// Get list of snapshots for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>ApiResponse of InlineResponse2009</returns>
        ApiResponse<InlineResponse2009> ListSnapshotsWithHttpInfo (string collectionName);
        /// <summary>
        /// Recover from a snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 RecoverFromSnapshot (string collectionName, SnapshotRecover body = null, bool? wait = null);

        /// <summary>
        /// Recover from a snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> RecoverFromSnapshotWithHttpInfo (string collectionName, SnapshotRecover body = null, bool? wait = null);
        /// <summary>
        /// Recover from an uploaded snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 RecoverFromUploadedSnapshot (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority));

        /// <summary>
        /// Recover from an uploaded snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> RecoverFromUploadedSnapshotWithHttpInfo (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority));
        /// <summary>
        /// Update aliases of the collections
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 UpdateAliases (ChangeAliasesOperation body = null, int? timeout = null);

        /// <summary>
        /// Update aliases of the collections
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> UpdateAliasesWithHttpInfo (ChangeAliasesOperation body = null, int? timeout = null);
        /// <summary>
        /// Update collection parameters
        /// </summary>
        /// <remarks>
        /// Update parameters of the existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 UpdateCollection (string collectionName, UpdateCollection body = null, int? timeout = null);

        /// <summary>
        /// Update collection parameters
        /// </summary>
        /// <remarks>
        /// Update parameters of the existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> UpdateCollectionWithHttpInfo (string collectionName, UpdateCollection body = null, int? timeout = null);
        /// <summary>
        /// Update collection cluster setup
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        InlineResponse2003 UpdateCollectionCluster (string collectionName, ClusterOperations body = null, int? timeout = null);

        /// <summary>
        /// Update collection cluster setup
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        ApiResponse<InlineResponse2003> UpdateCollectionClusterWithHttpInfo (string collectionName, ClusterOperations body = null, int? timeout = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Collection cluster info
        /// </summary>
        /// <remarks>
        /// Get cluster information for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>Task of InlineResponse2007</returns>
        System.Threading.Tasks.Task<InlineResponse2007> CollectionClusterInfoAsync (string collectionName);

        /// <summary>
        /// Collection cluster info
        /// </summary>
        /// <remarks>
        /// Get cluster information for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>Task of ApiResponse (InlineResponse2007)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2007>> CollectionClusterInfoAsyncWithHttpInfo (string collectionName);
        /// <summary>
        /// Create collection
        /// </summary>
        /// <remarks>
        /// Create new collection with given parameters
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> CreateCollectionAsync (string collectionName, CreateCollection body = null, int? timeout = null);

        /// <summary>
        /// Create collection
        /// </summary>
        /// <remarks>
        /// Create new collection with given parameters
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> CreateCollectionAsyncWithHttpInfo (string collectionName, CreateCollection body = null, int? timeout = null);
        /// <summary>
        /// Create index for field in collection
        /// </summary>
        /// <remarks>
        /// Create index for field in collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> CreateFieldIndexAsync (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);

        /// <summary>
        /// Create index for field in collection
        /// </summary>
        /// <remarks>
        /// Create index for field in collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> CreateFieldIndexAsyncWithHttpInfo (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);
        /// <summary>
        /// Create collection snapshot
        /// </summary>
        /// <remarks>
        /// Create new snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of InlineResponse20010</returns>
        System.Threading.Tasks.Task<InlineResponse20010> CreateSnapshotAsync (string collectionName, bool? wait = null);

        /// <summary>
        /// Create collection snapshot
        /// </summary>
        /// <remarks>
        /// Create new snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20010)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20010>> CreateSnapshotAsyncWithHttpInfo (string collectionName, bool? wait = null);
        /// <summary>
        /// Delete collection
        /// </summary>
        /// <remarks>
        /// Drop collection and all associated data
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> DeleteCollectionAsync (string collectionName, int? timeout = null);

        /// <summary>
        /// Delete collection
        /// </summary>
        /// <remarks>
        /// Drop collection and all associated data
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> DeleteCollectionAsyncWithHttpInfo (string collectionName, int? timeout = null);
        /// <summary>
        /// Delete index for field in collection
        /// </summary>
        /// <remarks>
        /// Delete field index for collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> DeleteFieldIndexAsync (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);

        /// <summary>
        /// Delete index for field in collection
        /// </summary>
        /// <remarks>
        /// Delete field index for collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> DeleteFieldIndexAsyncWithHttpInfo (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak);
        /// <summary>
        /// Delete collection snapshot
        /// </summary>
        /// <remarks>
        /// Delete snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> DeleteSnapshotAsync (string collectionName, string snapshotName, bool? wait = null);

        /// <summary>
        /// Delete collection snapshot
        /// </summary>
        /// <remarks>
        /// Delete snapshot for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> DeleteSnapshotAsyncWithHttpInfo (string collectionName, string snapshotName, bool? wait = null);
        /// <summary>
        /// Collection info
        /// </summary>
        /// <remarks>
        /// Get detailed information about specified existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>Task of InlineResponse2005</returns>
        System.Threading.Tasks.Task<InlineResponse2005> GetCollectionAsync (string collectionName);

        /// <summary>
        /// Collection info
        /// </summary>
        /// <remarks>
        /// Get detailed information about specified existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>Task of ApiResponse (InlineResponse2005)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2005>> GetCollectionAsyncWithHttpInfo (string collectionName);
        /// <summary>
        /// List aliases for collection
        /// </summary>
        /// <remarks>
        /// Get list of all aliases for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of InlineResponse2008</returns>
        System.Threading.Tasks.Task<InlineResponse2008> GetCollectionAliasesAsync (string collectionName);

        /// <summary>
        /// List aliases for collection
        /// </summary>
        /// <remarks>
        /// Get list of all aliases for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2008>> GetCollectionAliasesAsyncWithHttpInfo (string collectionName);
        /// <summary>
        /// List collections
        /// </summary>
        /// <remarks>
        /// Get list name of all existing collections
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of InlineResponse2004</returns>
        System.Threading.Tasks.Task<InlineResponse2004> GetCollectionsAsync ();

        /// <summary>
        /// List collections
        /// </summary>
        /// <remarks>
        /// Get list name of all existing collections
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (InlineResponse2004)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2004>> GetCollectionsAsyncWithHttpInfo ();
        /// <summary>
        /// List collections aliases
        /// </summary>
        /// <remarks>
        /// Get list of all existing collections aliases
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of InlineResponse2008</returns>
        System.Threading.Tasks.Task<InlineResponse2008> GetCollectionsAliasesAsync ();

        /// <summary>
        /// List collections aliases
        /// </summary>
        /// <remarks>
        /// Get list of all existing collections aliases
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2008>> GetCollectionsAliasesAsyncWithHttpInfo ();
        /// <summary>
        /// Download collection snapshot
        /// </summary>
        /// <remarks>
        /// Download specified snapshot from a collection as a file
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>Task of byte[]</returns>
        System.Threading.Tasks.Task<byte[]> GetSnapshotAsync (string collectionName, string snapshotName);

        /// <summary>
        /// Download collection snapshot
        /// </summary>
        /// <remarks>
        /// Download specified snapshot from a collection as a file
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        System.Threading.Tasks.Task<ApiResponse<byte[]>> GetSnapshotAsyncWithHttpInfo (string collectionName, string snapshotName);
        /// <summary>
        /// List collection snapshots
        /// </summary>
        /// <remarks>
        /// Get list of snapshots for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of InlineResponse2009</returns>
        System.Threading.Tasks.Task<InlineResponse2009> ListSnapshotsAsync (string collectionName);

        /// <summary>
        /// List collection snapshots
        /// </summary>
        /// <remarks>
        /// Get list of snapshots for a collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of ApiResponse (InlineResponse2009)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2009>> ListSnapshotsAsyncWithHttpInfo (string collectionName);
        /// <summary>
        /// Recover from a snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> RecoverFromSnapshotAsync (string collectionName, SnapshotRecover body = null, bool? wait = null);

        /// <summary>
        /// Recover from a snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> RecoverFromSnapshotAsyncWithHttpInfo (string collectionName, SnapshotRecover body = null, bool? wait = null);
        /// <summary>
        /// Recover from an uploaded snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> RecoverFromUploadedSnapshotAsync (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority));

        /// <summary>
        /// Recover from an uploaded snapshot
        /// </summary>
        /// <remarks>
        /// Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> RecoverFromUploadedSnapshotAsyncWithHttpInfo (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority));
        /// <summary>
        /// Update aliases of the collections
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> UpdateAliasesAsync (ChangeAliasesOperation body = null, int? timeout = null);

        /// <summary>
        /// Update aliases of the collections
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> UpdateAliasesAsyncWithHttpInfo (ChangeAliasesOperation body = null, int? timeout = null);
        /// <summary>
        /// Update collection parameters
        /// </summary>
        /// <remarks>
        /// Update parameters of the existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> UpdateCollectionAsync (string collectionName, UpdateCollection body = null, int? timeout = null);

        /// <summary>
        /// Update collection parameters
        /// </summary>
        /// <remarks>
        /// Update parameters of the existing collection
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> UpdateCollectionAsyncWithHttpInfo (string collectionName, UpdateCollection body = null, int? timeout = null);
        /// <summary>
        /// Update collection cluster setup
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        System.Threading.Tasks.Task<InlineResponse2003> UpdateCollectionClusterAsync (string collectionName, ClusterOperations body = null, int? timeout = null);

        /// <summary>
        /// Update collection cluster setup
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> UpdateCollectionClusterAsyncWithHttpInfo (string collectionName, ClusterOperations body = null, int? timeout = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class CollectionsApi : ICollectionsApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="CollectionsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CollectionsApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CollectionsApi"/> class
        /// </summary>
        /// <returns></returns>
        public CollectionsApi()
        {
            this.Configuration = IO.Swagger.Client.Configuration.Default;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="CollectionsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public CollectionsApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Collection cluster info Get cluster information for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>InlineResponse2007</returns>
        public InlineResponse2007 CollectionClusterInfo (string collectionName)
        {
             ApiResponse<InlineResponse2007> localVarResponse = CollectionClusterInfoWithHttpInfo(collectionName);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Collection cluster info Get cluster information for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>ApiResponse of InlineResponse2007</returns>
        public ApiResponse< InlineResponse2007 > CollectionClusterInfoWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CollectionClusterInfo");

            var localVarPath = "/collections/{collection_name}/cluster";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CollectionClusterInfo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2007>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2007) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2007)));
        }

        /// <summary>
        /// Collection cluster info Get cluster information for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>Task of InlineResponse2007</returns>
        public async System.Threading.Tasks.Task<InlineResponse2007> CollectionClusterInfoAsync (string collectionName)
        {
             ApiResponse<InlineResponse2007> localVarResponse = await CollectionClusterInfoAsyncWithHttpInfo(collectionName);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Collection cluster info Get cluster information for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve the cluster info for</param>
        /// <returns>Task of ApiResponse (InlineResponse2007)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2007>> CollectionClusterInfoAsyncWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CollectionClusterInfo");

            var localVarPath = "/collections/{collection_name}/cluster";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CollectionClusterInfo", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2007>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2007) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2007)));
        }

        /// <summary>
        /// Create collection Create new collection with given parameters
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 CreateCollection (string collectionName, CreateCollection body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = CreateCollectionWithHttpInfo(collectionName, body, timeout);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create collection Create new collection with given parameters
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > CreateCollectionWithHttpInfo (string collectionName, CreateCollection body = null, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CreateCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Create collection Create new collection with given parameters
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> CreateCollectionAsync (string collectionName, CreateCollection body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = await CreateCollectionAsyncWithHttpInfo(collectionName, body, timeout);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create collection Create new collection with given parameters
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the new collection</param>
        /// <param name="body">Parameters of a new collection (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> CreateCollectionAsyncWithHttpInfo (string collectionName, CreateCollection body = null, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CreateCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Create index for field in collection Create index for field in collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 CreateFieldIndex (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
             ApiResponse<InlineResponse2006> localVarResponse = CreateFieldIndexWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create index for field in collection Create index for field in collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > CreateFieldIndexWithHttpInfo (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CreateFieldIndex");

            var localVarPath = "/collections/{collection_name}/index";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateFieldIndex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Create index for field in collection Create index for field in collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> CreateFieldIndexAsync (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
             ApiResponse<InlineResponse2006> localVarResponse = await CreateFieldIndexAsyncWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create index for field in collection Create index for field in collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Field name (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> CreateFieldIndexAsyncWithHttpInfo (string collectionName, CreateFieldIndex body = null, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CreateFieldIndex");

            var localVarPath = "/collections/{collection_name}/index";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateFieldIndex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Create collection snapshot Create new snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>InlineResponse20010</returns>
        public InlineResponse20010 CreateSnapshot (string collectionName, bool? wait = null)
        {
             ApiResponse<InlineResponse20010> localVarResponse = CreateSnapshotWithHttpInfo(collectionName, wait);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create collection snapshot Create new snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>ApiResponse of InlineResponse20010</returns>
        public ApiResponse< InlineResponse20010 > CreateSnapshotWithHttpInfo (string collectionName, bool? wait = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CreateSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20010>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20010) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20010)));
        }

        /// <summary>
        /// Create collection snapshot Create new snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of InlineResponse20010</returns>
        public async System.Threading.Tasks.Task<InlineResponse20010> CreateSnapshotAsync (string collectionName, bool? wait = null)
        {
             ApiResponse<InlineResponse20010> localVarResponse = await CreateSnapshotAsyncWithHttpInfo(collectionName, wait);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create collection snapshot Create new snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to create a snapshot</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20010)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20010>> CreateSnapshotAsyncWithHttpInfo (string collectionName, bool? wait = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->CreateSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20010>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20010) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20010)));
        }

        /// <summary>
        /// Delete collection Drop collection and all associated data
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 DeleteCollection (string collectionName, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = DeleteCollectionWithHttpInfo(collectionName, timeout);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete collection Drop collection and all associated data
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > DeleteCollectionWithHttpInfo (string collectionName, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->DeleteCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Delete collection Drop collection and all associated data
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> DeleteCollectionAsync (string collectionName, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = await DeleteCollectionAsyncWithHttpInfo(collectionName, timeout);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete collection Drop collection and all associated data
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> DeleteCollectionAsyncWithHttpInfo (string collectionName, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->DeleteCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Delete index for field in collection Delete field index for collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 DeleteFieldIndex (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
             ApiResponse<InlineResponse2006> localVarResponse = DeleteFieldIndexWithHttpInfo(collectionName, fieldName, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete index for field in collection Delete field index for collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > DeleteFieldIndexWithHttpInfo (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->DeleteFieldIndex");
            // verify the required parameter 'fieldName' is set
            if (fieldName == null)
                throw new ApiException(400, "Missing required parameter 'fieldName' when calling CollectionsApi->DeleteFieldIndex");

            var localVarPath = "/collections/{collection_name}/index/{field_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (fieldName != null) localVarPathParams.Add("field_name", this.Configuration.ApiClient.ParameterToString(fieldName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteFieldIndex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Delete index for field in collection Delete field index for collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> DeleteFieldIndexAsync (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
             ApiResponse<InlineResponse2006> localVarResponse = await DeleteFieldIndexAsyncWithHttpInfo(collectionName, fieldName, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete index for field in collection Delete field index for collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="fieldName">Name of the field where to delete the index</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> DeleteFieldIndexAsyncWithHttpInfo (string collectionName, string fieldName, bool? wait = null, WriteOrdering ordering = WriteOrdering.Weak)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->DeleteFieldIndex");
            // verify the required parameter 'fieldName' is set
            if (fieldName == null)
                throw new ApiException(400, "Missing required parameter 'fieldName' when calling CollectionsApi->DeleteFieldIndex");

            var localVarPath = "/collections/{collection_name}/index/{field_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (fieldName != null) localVarPathParams.Add("field_name", this.Configuration.ApiClient.ParameterToString(fieldName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteFieldIndex", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Delete collection snapshot Delete snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 DeleteSnapshot (string collectionName, string snapshotName, bool? wait = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = DeleteSnapshotWithHttpInfo(collectionName, snapshotName, wait);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete collection snapshot Delete snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > DeleteSnapshotWithHttpInfo (string collectionName, string snapshotName, bool? wait = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->DeleteSnapshot");
            // verify the required parameter 'snapshotName' is set
            if (snapshotName == null)
                throw new ApiException(400, "Missing required parameter 'snapshotName' when calling CollectionsApi->DeleteSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/{snapshot_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (snapshotName != null) localVarPathParams.Add("snapshot_name", this.Configuration.ApiClient.ParameterToString(snapshotName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Delete collection snapshot Delete snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> DeleteSnapshotAsync (string collectionName, string snapshotName, bool? wait = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = await DeleteSnapshotAsyncWithHttpInfo(collectionName, snapshotName, wait);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete collection snapshot Delete snapshot for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection for which to delete a snapshot</param>
        /// <param name="snapshotName">Name of the snapshot to delete</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> DeleteSnapshotAsyncWithHttpInfo (string collectionName, string snapshotName, bool? wait = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->DeleteSnapshot");
            // verify the required parameter 'snapshotName' is set
            if (snapshotName == null)
                throw new ApiException(400, "Missing required parameter 'snapshotName' when calling CollectionsApi->DeleteSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/{snapshot_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (snapshotName != null) localVarPathParams.Add("snapshot_name", this.Configuration.ApiClient.ParameterToString(snapshotName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Collection info Get detailed information about specified existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>InlineResponse2005</returns>
        public InlineResponse2005 GetCollection (string collectionName)
        {
             ApiResponse<InlineResponse2005> localVarResponse = GetCollectionWithHttpInfo(collectionName);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Collection info Get detailed information about specified existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>ApiResponse of InlineResponse2005</returns>
        public ApiResponse< InlineResponse2005 > GetCollectionWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->GetCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2005>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2005) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2005)));
        }

        /// <summary>
        /// Collection info Get detailed information about specified existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>Task of InlineResponse2005</returns>
        public async System.Threading.Tasks.Task<InlineResponse2005> GetCollectionAsync (string collectionName)
        {
             ApiResponse<InlineResponse2005> localVarResponse = await GetCollectionAsyncWithHttpInfo(collectionName);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Collection info Get detailed information about specified existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve</param>
        /// <returns>Task of ApiResponse (InlineResponse2005)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2005>> GetCollectionAsyncWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->GetCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2005>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2005) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2005)));
        }

        /// <summary>
        /// List aliases for collection Get list of all aliases for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>InlineResponse2008</returns>
        public InlineResponse2008 GetCollectionAliases (string collectionName)
        {
             ApiResponse<InlineResponse2008> localVarResponse = GetCollectionAliasesWithHttpInfo(collectionName);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List aliases for collection Get list of all aliases for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        public ApiResponse< InlineResponse2008 > GetCollectionAliasesWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->GetCollectionAliases");

            var localVarPath = "/collections/{collection_name}/aliases";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollectionAliases", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2008>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2008) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2008)));
        }

        /// <summary>
        /// List aliases for collection Get list of all aliases for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of InlineResponse2008</returns>
        public async System.Threading.Tasks.Task<InlineResponse2008> GetCollectionAliasesAsync (string collectionName)
        {
             ApiResponse<InlineResponse2008> localVarResponse = await GetCollectionAliasesAsyncWithHttpInfo(collectionName);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List aliases for collection Get list of all aliases for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2008>> GetCollectionAliasesAsyncWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->GetCollectionAliases");

            var localVarPath = "/collections/{collection_name}/aliases";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollectionAliases", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2008>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2008) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2008)));
        }

        /// <summary>
        /// List collections Get list name of all existing collections
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>InlineResponse2004</returns>
        public InlineResponse2004 GetCollections ()
        {
             ApiResponse<InlineResponse2004> localVarResponse = GetCollectionsWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// List collections Get list name of all existing collections
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of InlineResponse2004</returns>
        public ApiResponse< InlineResponse2004 > GetCollectionsWithHttpInfo ()
        {

            var localVarPath = "/collections";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollections", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2004>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2004) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2004)));
        }

        /// <summary>
        /// List collections Get list name of all existing collections
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of InlineResponse2004</returns>
        public async System.Threading.Tasks.Task<InlineResponse2004> GetCollectionsAsync ()
        {
             ApiResponse<InlineResponse2004> localVarResponse = await GetCollectionsAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// List collections Get list name of all existing collections
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (InlineResponse2004)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2004>> GetCollectionsAsyncWithHttpInfo ()
        {

            var localVarPath = "/collections";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollections", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2004>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2004) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2004)));
        }

        /// <summary>
        /// List collections aliases Get list of all existing collections aliases
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>InlineResponse2008</returns>
        public InlineResponse2008 GetCollectionsAliases ()
        {
             ApiResponse<InlineResponse2008> localVarResponse = GetCollectionsAliasesWithHttpInfo();
             return localVarResponse.Data;
        }

        /// <summary>
        /// List collections aliases Get list of all existing collections aliases
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of InlineResponse2008</returns>
        public ApiResponse< InlineResponse2008 > GetCollectionsAliasesWithHttpInfo ()
        {

            var localVarPath = "/aliases";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollectionsAliases", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2008>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2008) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2008)));
        }

        /// <summary>
        /// List collections aliases Get list of all existing collections aliases
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of InlineResponse2008</returns>
        public async System.Threading.Tasks.Task<InlineResponse2008> GetCollectionsAliasesAsync ()
        {
             ApiResponse<InlineResponse2008> localVarResponse = await GetCollectionsAliasesAsyncWithHttpInfo();
             return localVarResponse.Data;

        }

        /// <summary>
        /// List collections aliases Get list of all existing collections aliases
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>Task of ApiResponse (InlineResponse2008)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2008>> GetCollectionsAliasesAsyncWithHttpInfo ()
        {

            var localVarPath = "/aliases";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetCollectionsAliases", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2008>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2008) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2008)));
        }

        /// <summary>
        /// Download collection snapshot Download specified snapshot from a collection as a file
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>byte[]</returns>
        public byte[] GetSnapshot (string collectionName, string snapshotName)
        {
             ApiResponse<byte[]> localVarResponse = GetSnapshotWithHttpInfo(collectionName, snapshotName);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Download collection snapshot Download specified snapshot from a collection as a file
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>ApiResponse of byte[]</returns>
        public ApiResponse< byte[] > GetSnapshotWithHttpInfo (string collectionName, string snapshotName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->GetSnapshot");
            // verify the required parameter 'snapshotName' is set
            if (snapshotName == null)
                throw new ApiException(400, "Missing required parameter 'snapshotName' when calling CollectionsApi->GetSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/{snapshot_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream",
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (snapshotName != null) localVarPathParams.Add("snapshot_name", this.Configuration.ApiClient.ParameterToString(snapshotName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<byte[]>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (byte[]) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(byte[])));
        }

        /// <summary>
        /// Download collection snapshot Download specified snapshot from a collection as a file
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>Task of byte[]</returns>
        public async System.Threading.Tasks.Task<byte[]> GetSnapshotAsync (string collectionName, string snapshotName)
        {
             ApiResponse<byte[]> localVarResponse = await GetSnapshotAsyncWithHttpInfo(collectionName, snapshotName);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Download collection snapshot Download specified snapshot from a collection as a file
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshotName">Name of the snapshot to download</param>
        /// <returns>Task of ApiResponse (byte[])</returns>
        public async System.Threading.Tasks.Task<ApiResponse<byte[]>> GetSnapshotAsyncWithHttpInfo (string collectionName, string snapshotName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->GetSnapshot");
            // verify the required parameter 'snapshotName' is set
            if (snapshotName == null)
                throw new ApiException(400, "Missing required parameter 'snapshotName' when calling CollectionsApi->GetSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/{snapshot_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/octet-stream",
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (snapshotName != null) localVarPathParams.Add("snapshot_name", this.Configuration.ApiClient.ParameterToString(snapshotName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<byte[]>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (byte[]) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(byte[])));
        }

        /// <summary>
        /// List collection snapshots Get list of snapshots for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>InlineResponse2009</returns>
        public InlineResponse2009 ListSnapshots (string collectionName)
        {
             ApiResponse<InlineResponse2009> localVarResponse = ListSnapshotsWithHttpInfo(collectionName);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List collection snapshots Get list of snapshots for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>ApiResponse of InlineResponse2009</returns>
        public ApiResponse< InlineResponse2009 > ListSnapshotsWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->ListSnapshots");

            var localVarPath = "/collections/{collection_name}/snapshots";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListSnapshots", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2009>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2009) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2009)));
        }

        /// <summary>
        /// List collection snapshots Get list of snapshots for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of InlineResponse2009</returns>
        public async System.Threading.Tasks.Task<InlineResponse2009> ListSnapshotsAsync (string collectionName)
        {
             ApiResponse<InlineResponse2009> localVarResponse = await ListSnapshotsAsyncWithHttpInfo(collectionName);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List collection snapshots Get list of snapshots for a collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <returns>Task of ApiResponse (InlineResponse2009)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2009>> ListSnapshotsAsyncWithHttpInfo (string collectionName)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->ListSnapshots");

            var localVarPath = "/collections/{collection_name}/snapshots";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListSnapshots", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2009>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2009) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2009)));
        }

        /// <summary>
        /// Recover from a snapshot Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 RecoverFromSnapshot (string collectionName, SnapshotRecover body = null, bool? wait = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = RecoverFromSnapshotWithHttpInfo(collectionName, body, wait);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Recover from a snapshot Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > RecoverFromSnapshotWithHttpInfo (string collectionName, SnapshotRecover body = null, bool? wait = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->RecoverFromSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/recover";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecoverFromSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Recover from a snapshot Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> RecoverFromSnapshotAsync (string collectionName, SnapshotRecover body = null, bool? wait = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = await RecoverFromSnapshotAsyncWithHttpInfo(collectionName, body, wait);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Recover from a snapshot Recover local collection data from a snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="body">Snapshot to recover from (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> RecoverFromSnapshotAsyncWithHttpInfo (string collectionName, SnapshotRecover body = null, bool? wait = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->RecoverFromSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/recover";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecoverFromSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Recover from an uploaded snapshot Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 RecoverFromUploadedSnapshot (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority))
        {
             ApiResponse<InlineResponse2003> localVarResponse = RecoverFromUploadedSnapshotWithHttpInfo(collectionName, snapshot, wait, priority);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Recover from an uploaded snapshot Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > RecoverFromUploadedSnapshotWithHttpInfo (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->RecoverFromUploadedSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/upload";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (priority != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "priority", priority)); // query parameter
            if (snapshot != null) localVarFileParams.Add("snapshot", this.Configuration.ApiClient.ParameterToFile("snapshot", snapshot));

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecoverFromUploadedSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Recover from an uploaded snapshot Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> RecoverFromUploadedSnapshotAsync (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority))
        {
             ApiResponse<InlineResponse2003> localVarResponse = await RecoverFromUploadedSnapshotAsyncWithHttpInfo(collectionName, snapshot, wait, priority);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Recover from an uploaded snapshot Recover local collection data from an uploaded snapshot. This will overwrite any data, stored on this node, for the collection. If collection does not exist - it will be created.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection</param>
        /// <param name="snapshot"> (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen. If false - let changes happen in background. Default is true. (optional)</param>
        /// <param name="priority">Defines source of truth for snapshot recovery (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> RecoverFromUploadedSnapshotAsyncWithHttpInfo (string collectionName, byte[] snapshot = null, bool? wait = null, SnapshotPriority priority = default(SnapshotPriority))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->RecoverFromUploadedSnapshot");

            var localVarPath = "/collections/{collection_name}/snapshots/upload";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "multipart/form-data"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (priority != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "priority", priority)); // query parameter
            if (snapshot != null) localVarFileParams.Add("snapshot", this.Configuration.ApiClient.ParameterToFile("snapshot", snapshot));

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecoverFromUploadedSnapshot", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Update aliases of the collections 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 UpdateAliases (ChangeAliasesOperation body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = UpdateAliasesWithHttpInfo(body, timeout);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update aliases of the collections 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > UpdateAliasesWithHttpInfo (ChangeAliasesOperation body = null, int? timeout = null)
        {

            var localVarPath = "/collections/aliases";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateAliases", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Update aliases of the collections 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> UpdateAliasesAsync (ChangeAliasesOperation body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = await UpdateAliasesAsyncWithHttpInfo(body, timeout);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update aliases of the collections 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">Alias update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> UpdateAliasesAsyncWithHttpInfo (ChangeAliasesOperation body = null, int? timeout = null)
        {

            var localVarPath = "/collections/aliases";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateAliases", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Update collection parameters Update parameters of the existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 UpdateCollection (string collectionName, UpdateCollection body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = UpdateCollectionWithHttpInfo(collectionName, body, timeout);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update collection parameters Update parameters of the existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > UpdateCollectionWithHttpInfo (string collectionName, UpdateCollection body = null, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->UpdateCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Update collection parameters Update parameters of the existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> UpdateCollectionAsync (string collectionName, UpdateCollection body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = await UpdateCollectionAsyncWithHttpInfo(collectionName, body, timeout);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update collection parameters Update parameters of the existing collection
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update</param>
        /// <param name="body">New parameters (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> UpdateCollectionAsyncWithHttpInfo (string collectionName, UpdateCollection body = null, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->UpdateCollection");

            var localVarPath = "/collections/{collection_name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCollection", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Update collection cluster setup 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>InlineResponse2003</returns>
        public InlineResponse2003 UpdateCollectionCluster (string collectionName, ClusterOperations body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = UpdateCollectionClusterWithHttpInfo(collectionName, body, timeout);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update collection cluster setup 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>ApiResponse of InlineResponse2003</returns>
        public ApiResponse< InlineResponse2003 > UpdateCollectionClusterWithHttpInfo (string collectionName, ClusterOperations body = null, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->UpdateCollectionCluster");

            var localVarPath = "/collections/{collection_name}/cluster";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCollectionCluster", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

        /// <summary>
        /// Update collection cluster setup 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of InlineResponse2003</returns>
        public async System.Threading.Tasks.Task<InlineResponse2003> UpdateCollectionClusterAsync (string collectionName, ClusterOperations body = null, int? timeout = null)
        {
             ApiResponse<InlineResponse2003> localVarResponse = await UpdateCollectionClusterAsyncWithHttpInfo(collectionName, body, timeout);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update collection cluster setup 
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection on which to to apply the cluster update operation</param>
        /// <param name="body">Collection cluster update operations (optional)</param>
        /// <param name="timeout">Wait for operation commit timeout in seconds.  If timeout is reached - request will return with service error.  (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2003)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2003>> UpdateCollectionClusterAsyncWithHttpInfo (string collectionName, ClusterOperations body = null, int? timeout = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling CollectionsApi->UpdateCollectionCluster");

            var localVarPath = "/collections/{collection_name}/cluster";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (timeout != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeout", timeout)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateCollectionCluster", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2003>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2003) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2003)));
        }

    }
}
