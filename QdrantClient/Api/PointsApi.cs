/* 
 * Qdrant API
 *
 * API description for Qdrant vector search engine.  This document describes CRUD and search operations on collections of points (vectors with payload).  Qdrant supports any combinations of `should`, `must` and `must_not` conditions, which makes it possible to use in applications when object could not be described solely by vector. It could be location features, availability flags, and other custom properties businesses should take into account. ## Examples This examples cover the most basic use-cases - collection creation and basic vector search. ### Create collection First - let's create a collection with dot-production metric. ``` curl -X PUT 'http://localhost:6333/collections/test_collection' \\   -H 'Content-Type: application/json' \\   - -data-raw '{     \"vectors\": {       \"size\": 4,       \"distance\": \"Dot\"     }   }'  ``` Expected response: ``` {     \"result\": true,     \"status\": \"ok\",     \"time\": 0.031095451 } ``` We can ensure that collection was created: ``` curl 'http://localhost:6333/collections/test_collection' ``` Expected response: ``` {   \"result\": {     \"status\": \"green\",     \"vectors_count\": 0,     \"segments_count\": 5,     \"disk_data_size\": 0,     \"ram_data_size\": 0,     \"config\": {       \"params\": {         \"vectors\": {           \"size\": 4,           \"distance\": \"Dot\"         }       },       \"hnsw_config\": {         \"m\": 16,         \"ef_construct\": 100,         \"full_scan_threshold\": 10000       },       \"optimizer_config\": {         \"deleted_threshold\": 0.2,         \"vacuum_min_vector_number\": 1000,         \"max_segment_number\": 5,         \"memmap_threshold\": 50000,         \"indexing_threshold\": 20000,         \"flush_interval_sec\": 1       },       \"wal_config\": {         \"wal_capacity_mb\": 32,         \"wal_segments_ahead\": 0       }     }   },   \"status\": \"ok\",   \"time\": 2.1199e-05 } ```  ### Add points Let's now add vectors with some payload: ``` curl -L -X PUT 'http://localhost:6333/collections/test_collection/points?wait=true' \\ -H 'Content-Type: application/json' \\ - -data-raw '{   \"points\": [     {\"id\": 1, \"vector\": [0.05, 0.61, 0.76, 0.74], \"payload\": {\"city\": \"Berlin\"}},     {\"id\": 2, \"vector\": [0.19, 0.81, 0.75, 0.11], \"payload\": {\"city\": [\"Berlin\", \"London\"] }},     {\"id\": 3, \"vector\": [0.36, 0.55, 0.47, 0.94], \"payload\": {\"city\": [\"Berlin\", \"Moscow\"] }},     {\"id\": 4, \"vector\": [0.18, 0.01, 0.85, 0.80], \"payload\": {\"city\": [\"London\", \"Moscow\"] }},     {\"id\": 5, \"vector\": [0.24, 0.18, 0.22, 0.44], \"payload\": {\"count\": [0]}},     {\"id\": 6, \"vector\": [0.35, 0.08, 0.11, 0.44]}   ] }' ``` Expected response: ``` {     \"result\": {         \"operation_id\": 0,         \"status\": \"completed\"     },     \"status\": \"ok\",     \"time\": 0.000206061 } ``` ### Search with filtering Let's start with a basic request: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ - -data-raw '{     \"vector\": [0.2,0.1,0.9,0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 1, \"score\": 1.273, \"payload\": null, \"version\": 0 },         { \"id\": 3, \"score\": 1.208, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000055785 } ``` But result is different if we add a filter: ``` curl -L -X POST 'http://localhost:6333/collections/test_collection/points/search' \\ -H 'Content-Type: application/json' \\ - -data-raw '{     \"filter\": {         \"should\": [             {                 \"key\": \"city\",                 \"match\": {                     \"value\": \"London\"                 }             }         ]     },     \"vector\": [0.2, 0.1, 0.9, 0.7],     \"top\": 3 }' ``` Expected response: ``` {     \"result\": [         { \"id\": 4, \"score\": 1.362, \"payload\": null, \"version\": 0 },         { \"id\": 2, \"score\": 0.871, \"payload\": null, \"version\": 0 }     ],     \"status\": \"ok\",     \"time\": 0.000093972 } ``` 
 *
 * OpenAPI spec version: v1.1.3
 * Contact: andrey@vasnetsov.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using IO.Swagger.Client;
using IO.Swagger.Model;

namespace IO.Swagger.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public interface IPointsApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Clear payload
        /// </summary>
        /// <remarks>
        /// Remove all payload for specified points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 ClearPayload (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Clear payload
        /// </summary>
        /// <remarks>
        /// Remove all payload for specified points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> ClearPayloadWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Count points
        /// </summary>
        /// <remarks>
        /// Count points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>InlineResponse20016</returns>
        InlineResponse20016 CountPoints (string collectionName, CountRequest body = null);

        /// <summary>
        /// Count points
        /// </summary>
        /// <remarks>
        /// Count points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>ApiResponse of InlineResponse20016</returns>
        ApiResponse<InlineResponse20016> CountPointsWithHttpInfo (string collectionName, CountRequest body = null);
        /// <summary>
        /// Delete payload
        /// </summary>
        /// <remarks>
        /// Delete specified key payload for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 DeletePayload (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Delete payload
        /// </summary>
        /// <remarks>
        /// Delete specified key payload for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> DeletePayloadWithHttpInfo (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Delete points
        /// </summary>
        /// <remarks>
        /// Delete points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 DeletePoints (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Delete points
        /// </summary>
        /// <remarks>
        /// Delete points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> DeletePointsWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Get point
        /// </summary>
        /// <remarks>
        /// Retrieve full information of single point by id
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20011</returns>
        InlineResponse20011 GetPoint (string collectionName, ExtendedPointId id, ReadConsistency consistency = null);

        /// <summary>
        /// Get point
        /// </summary>
        /// <remarks>
        /// Retrieve full information of single point by id
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20011</returns>
        ApiResponse<InlineResponse20011> GetPointWithHttpInfo (string collectionName, ExtendedPointId id, ReadConsistency consistency = null);
        /// <summary>
        /// Get points
        /// </summary>
        /// <remarks>
        /// Retrieve multiple points by specified IDs
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20012</returns>
        InlineResponse20012 GetPoints (string collectionName, PointRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Get points
        /// </summary>
        /// <remarks>
        /// Retrieve multiple points by specified IDs
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20012</returns>
        ApiResponse<InlineResponse20012> GetPointsWithHttpInfo (string collectionName, PointRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Overwrite payload
        /// </summary>
        /// <remarks>
        /// Replace full payload of points with new one
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 OverwritePayload (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Overwrite payload
        /// </summary>
        /// <remarks>
        /// Replace full payload of points with new one
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> OverwritePayloadWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Recommend batch points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20015</returns>
        InlineResponse20015 RecommendBatchPoints (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Recommend batch points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20015</returns>
        ApiResponse<InlineResponse20015> RecommendBatchPointsWithHttpInfo (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Recommend points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20014</returns>
        InlineResponse20014 RecommendPoints (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Recommend points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20014</returns>
        ApiResponse<InlineResponse20014> RecommendPointsWithHttpInfo (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Scroll points
        /// </summary>
        /// <remarks>
        /// Scroll request - paginate over all points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20013</returns>
        InlineResponse20013 ScrollPoints (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Scroll points
        /// </summary>
        /// <remarks>
        /// Scroll request - paginate over all points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20013</returns>
        ApiResponse<InlineResponse20013> ScrollPointsWithHttpInfo (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Search batch points
        /// </summary>
        /// <remarks>
        /// Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20015</returns>
        InlineResponse20015 SearchBatchPoints (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Search batch points
        /// </summary>
        /// <remarks>
        /// Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20015</returns>
        ApiResponse<InlineResponse20015> SearchBatchPointsWithHttpInfo (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Search points
        /// </summary>
        /// <remarks>
        /// Retrieve closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20014</returns>
        InlineResponse20014 SearchPoints (string collectionName, SearchRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Search points
        /// </summary>
        /// <remarks>
        /// Retrieve closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20014</returns>
        ApiResponse<InlineResponse20014> SearchPointsWithHttpInfo (string collectionName, SearchRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Set payload
        /// </summary>
        /// <remarks>
        /// Set payload values for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 SetPayload (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Set payload
        /// </summary>
        /// <remarks>
        /// Set payload values for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> SetPayloadWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Upsert points
        /// </summary>
        /// <remarks>
        /// Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        InlineResponse2006 UpsertPoints (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Upsert points
        /// </summary>
        /// <remarks>
        /// Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        ApiResponse<InlineResponse2006> UpsertPointsWithHttpInfo (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Clear payload
        /// </summary>
        /// <remarks>
        /// Remove all payload for specified points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> ClearPayloadAsync (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Clear payload
        /// </summary>
        /// <remarks>
        /// Remove all payload for specified points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> ClearPayloadAsyncWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Count points
        /// </summary>
        /// <remarks>
        /// Count points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>Task of InlineResponse20016</returns>
        System.Threading.Tasks.Task<InlineResponse20016> CountPointsAsync (string collectionName, CountRequest body = null);

        /// <summary>
        /// Count points
        /// </summary>
        /// <remarks>
        /// Count points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20016)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20016>> CountPointsAsyncWithHttpInfo (string collectionName, CountRequest body = null);
        /// <summary>
        /// Delete payload
        /// </summary>
        /// <remarks>
        /// Delete specified key payload for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> DeletePayloadAsync (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Delete payload
        /// </summary>
        /// <remarks>
        /// Delete specified key payload for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> DeletePayloadAsyncWithHttpInfo (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Delete points
        /// </summary>
        /// <remarks>
        /// Delete points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> DeletePointsAsync (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Delete points
        /// </summary>
        /// <remarks>
        /// Delete points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> DeletePointsAsyncWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Get point
        /// </summary>
        /// <remarks>
        /// Retrieve full information of single point by id
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20011</returns>
        System.Threading.Tasks.Task<InlineResponse20011> GetPointAsync (string collectionName, ExtendedPointId id, ReadConsistency consistency = null);

        /// <summary>
        /// Get point
        /// </summary>
        /// <remarks>
        /// Retrieve full information of single point by id
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20011)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20011>> GetPointAsyncWithHttpInfo (string collectionName, ExtendedPointId id, ReadConsistency consistency = null);
        /// <summary>
        /// Get points
        /// </summary>
        /// <remarks>
        /// Retrieve multiple points by specified IDs
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20012</returns>
        System.Threading.Tasks.Task<InlineResponse20012> GetPointsAsync (string collectionName, PointRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Get points
        /// </summary>
        /// <remarks>
        /// Retrieve multiple points by specified IDs
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20012)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20012>> GetPointsAsyncWithHttpInfo (string collectionName, PointRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Overwrite payload
        /// </summary>
        /// <remarks>
        /// Replace full payload of points with new one
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> OverwritePayloadAsync (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Overwrite payload
        /// </summary>
        /// <remarks>
        /// Replace full payload of points with new one
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> OverwritePayloadAsyncWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Recommend batch points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20015</returns>
        System.Threading.Tasks.Task<InlineResponse20015> RecommendBatchPointsAsync (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Recommend batch points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20015)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20015>> RecommendBatchPointsAsyncWithHttpInfo (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Recommend points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20014</returns>
        System.Threading.Tasks.Task<InlineResponse20014> RecommendPointsAsync (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Recommend points
        /// </summary>
        /// <remarks>
        /// Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20014)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20014>> RecommendPointsAsyncWithHttpInfo (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Scroll points
        /// </summary>
        /// <remarks>
        /// Scroll request - paginate over all points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20013</returns>
        System.Threading.Tasks.Task<InlineResponse20013> ScrollPointsAsync (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Scroll points
        /// </summary>
        /// <remarks>
        /// Scroll request - paginate over all points which matches given filtering condition
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20013)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20013>> ScrollPointsAsyncWithHttpInfo (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Search batch points
        /// </summary>
        /// <remarks>
        /// Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20015</returns>
        System.Threading.Tasks.Task<InlineResponse20015> SearchBatchPointsAsync (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Search batch points
        /// </summary>
        /// <remarks>
        /// Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20015)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20015>> SearchBatchPointsAsyncWithHttpInfo (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Search points
        /// </summary>
        /// <remarks>
        /// Retrieve closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20014</returns>
        System.Threading.Tasks.Task<InlineResponse20014> SearchPointsAsync (string collectionName, SearchRequest body = null, ReadConsistency consistency = null);

        /// <summary>
        /// Search points
        /// </summary>
        /// <remarks>
        /// Retrieve closest points based on vector similarity and given filtering conditions
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20014)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse20014>> SearchPointsAsyncWithHttpInfo (string collectionName, SearchRequest body = null, ReadConsistency consistency = null);
        /// <summary>
        /// Set payload
        /// </summary>
        /// <remarks>
        /// Set payload values for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> SetPayloadAsync (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Set payload
        /// </summary>
        /// <remarks>
        /// Set payload values for points
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> SetPayloadAsyncWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        /// <summary>
        /// Upsert points
        /// </summary>
        /// <remarks>
        /// Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        System.Threading.Tasks.Task<InlineResponse2006> UpsertPointsAsync (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));

        /// <summary>
        /// Upsert points
        /// </summary>
        /// <remarks>
        /// Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </remarks>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> UpsertPointsAsyncWithHttpInfo (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
        public partial class PointsApi : IPointsApi
    {
        private IO.Swagger.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="PointsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PointsApi(String basePath)
        {
            this.Configuration = new IO.Swagger.Client.Configuration { BasePath = basePath };

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PointsApi"/> class
        /// </summary>
        /// <returns></returns>
        public PointsApi()
        {
            this.Configuration = IO.Swagger.Client.Configuration.Default;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="PointsApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public PointsApi(IO.Swagger.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = IO.Swagger.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = IO.Swagger.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public IO.Swagger.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public IO.Swagger.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Clear payload Remove all payload for specified points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 ClearPayload (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = ClearPayloadWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Clear payload Remove all payload for specified points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > ClearPayloadWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->ClearPayload");

            var localVarPath = "/collections/{collection_name}/points/payload/clear";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ClearPayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Clear payload Remove all payload for specified points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> ClearPayloadAsync (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = await ClearPayloadAsyncWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Clear payload Remove all payload for specified points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to clear payload from</param>
        /// <param name="body">clear payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> ClearPayloadAsyncWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->ClearPayload");

            var localVarPath = "/collections/{collection_name}/points/payload/clear";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ClearPayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Count points Count points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>InlineResponse20016</returns>
        public InlineResponse20016 CountPoints (string collectionName, CountRequest body = null)
        {
             ApiResponse<InlineResponse20016> localVarResponse = CountPointsWithHttpInfo(collectionName, body);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Count points Count points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>ApiResponse of InlineResponse20016</returns>
        public ApiResponse< InlineResponse20016 > CountPointsWithHttpInfo (string collectionName, CountRequest body = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->CountPoints");

            var localVarPath = "/collections/{collection_name}/points/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CountPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20016>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20016) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20016)));
        }

        /// <summary>
        /// Count points Count points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>Task of InlineResponse20016</returns>
        public async System.Threading.Tasks.Task<InlineResponse20016> CountPointsAsync (string collectionName, CountRequest body = null)
        {
             ApiResponse<InlineResponse20016> localVarResponse = await CountPointsAsyncWithHttpInfo(collectionName, body);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Count points Count points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to count in</param>
        /// <param name="body">Request counts of points which matches given filtering condition (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20016)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20016>> CountPointsAsyncWithHttpInfo (string collectionName, CountRequest body = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->CountPoints");

            var localVarPath = "/collections/{collection_name}/points/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CountPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20016>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20016) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20016)));
        }

        /// <summary>
        /// Delete payload Delete specified key payload for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 DeletePayload (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = DeletePayloadWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete payload Delete specified key payload for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > DeletePayloadWithHttpInfo (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->DeletePayload");

            var localVarPath = "/collections/{collection_name}/points/payload/delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Delete payload Delete specified key payload for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> DeletePayloadAsync (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = await DeletePayloadAsyncWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete payload Delete specified key payload for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">delete payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> DeletePayloadAsyncWithHttpInfo (string collectionName, DeletePayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->DeletePayload");

            var localVarPath = "/collections/{collection_name}/points/payload/delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Delete points Delete points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 DeletePoints (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = DeletePointsWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Delete points Delete points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > DeletePointsWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->DeletePoints");

            var localVarPath = "/collections/{collection_name}/points/delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Delete points Delete points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> DeletePointsAsync (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = await DeletePointsAsyncWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Delete points Delete points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to delete from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> DeletePointsAsyncWithHttpInfo (string collectionName, PointsSelector body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->DeletePoints");

            var localVarPath = "/collections/{collection_name}/points/delete";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeletePoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Get point Retrieve full information of single point by id
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20011</returns>
        public InlineResponse20011 GetPoint (string collectionName, ExtendedPointId id, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20011> localVarResponse = GetPointWithHttpInfo(collectionName, id, consistency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get point Retrieve full information of single point by id
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20011</returns>
        public ApiResponse< InlineResponse20011 > GetPointWithHttpInfo (string collectionName, ExtendedPointId id, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->GetPoint");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PointsApi->GetPoint");

            var localVarPath = "/collections/{collection_name}/points/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPoint", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20011>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20011) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20011)));
        }

        /// <summary>
        /// Get point Retrieve full information of single point by id
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20011</returns>
        public async System.Threading.Tasks.Task<InlineResponse20011> GetPointAsync (string collectionName, ExtendedPointId id, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20011> localVarResponse = await GetPointAsyncWithHttpInfo(collectionName, id, consistency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get point Retrieve full information of single point by id
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="id">Id of the point</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20011)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20011>> GetPointAsyncWithHttpInfo (string collectionName, ExtendedPointId id, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->GetPoint");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling PointsApi->GetPoint");

            var localVarPath = "/collections/{collection_name}/points/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (id != null) localVarPathParams.Add("id", this.Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPoint", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20011>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20011) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20011)));
        }

        /// <summary>
        /// Get points Retrieve multiple points by specified IDs
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20012</returns>
        public InlineResponse20012 GetPoints (string collectionName, PointRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20012> localVarResponse = GetPointsWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get points Retrieve multiple points by specified IDs
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20012</returns>
        public ApiResponse< InlineResponse20012 > GetPointsWithHttpInfo (string collectionName, PointRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->GetPoints");

            var localVarPath = "/collections/{collection_name}/points";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20012>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20012) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20012)));
        }

        /// <summary>
        /// Get points Retrieve multiple points by specified IDs
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20012</returns>
        public async System.Threading.Tasks.Task<InlineResponse20012> GetPointsAsync (string collectionName, PointRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20012> localVarResponse = await GetPointsAsyncWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get points Retrieve multiple points by specified IDs
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">List of points to retrieve (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20012)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20012>> GetPointsAsyncWithHttpInfo (string collectionName, PointRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->GetPoints");

            var localVarPath = "/collections/{collection_name}/points";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20012>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20012) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20012)));
        }

        /// <summary>
        /// Overwrite payload Replace full payload of points with new one
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 OverwritePayload (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = OverwritePayloadWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Overwrite payload Replace full payload of points with new one
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > OverwritePayloadWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->OverwritePayload");

            var localVarPath = "/collections/{collection_name}/points/payload";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("OverwritePayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Overwrite payload Replace full payload of points with new one
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> OverwritePayloadAsync (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = await OverwritePayloadAsyncWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Overwrite payload Replace full payload of points with new one
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Payload and points selector (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> OverwritePayloadAsyncWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->OverwritePayload");

            var localVarPath = "/collections/{collection_name}/points/payload";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("OverwritePayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Recommend batch points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20015</returns>
        public InlineResponse20015 RecommendBatchPoints (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20015> localVarResponse = RecommendBatchPointsWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Recommend batch points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20015</returns>
        public ApiResponse< InlineResponse20015 > RecommendBatchPointsWithHttpInfo (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->RecommendBatchPoints");

            var localVarPath = "/collections/{collection_name}/points/recommend/batch";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecommendBatchPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20015>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20015) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20015)));
        }

        /// <summary>
        /// Recommend batch points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20015</returns>
        public async System.Threading.Tasks.Task<InlineResponse20015> RecommendBatchPointsAsync (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20015> localVarResponse = await RecommendBatchPointsAsyncWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Recommend batch points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20015)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20015>> RecommendBatchPointsAsyncWithHttpInfo (string collectionName, RecommendRequestBatch body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->RecommendBatchPoints");

            var localVarPath = "/collections/{collection_name}/points/recommend/batch";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecommendBatchPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20015>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20015) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20015)));
        }

        /// <summary>
        /// Recommend points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20014</returns>
        public InlineResponse20014 RecommendPoints (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20014> localVarResponse = RecommendPointsWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Recommend points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20014</returns>
        public ApiResponse< InlineResponse20014 > RecommendPointsWithHttpInfo (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->RecommendPoints");

            var localVarPath = "/collections/{collection_name}/points/recommend";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecommendPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20014>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20014) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20014)));
        }

        /// <summary>
        /// Recommend points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20014</returns>
        public async System.Threading.Tasks.Task<InlineResponse20014> RecommendPointsAsync (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20014> localVarResponse = await RecommendPointsAsyncWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Recommend points Look for the points which are closer to stored positive examples and at the same time further to negative examples.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Request points based on positive and negative examples. (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20014)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20014>> RecommendPointsAsyncWithHttpInfo (string collectionName, RecommendRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->RecommendPoints");

            var localVarPath = "/collections/{collection_name}/points/recommend";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RecommendPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20014>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20014) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20014)));
        }

        /// <summary>
        /// Scroll points Scroll request - paginate over all points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20013</returns>
        public InlineResponse20013 ScrollPoints (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20013> localVarResponse = ScrollPointsWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Scroll points Scroll request - paginate over all points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20013</returns>
        public ApiResponse< InlineResponse20013 > ScrollPointsWithHttpInfo (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->ScrollPoints");

            var localVarPath = "/collections/{collection_name}/points/scroll";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScrollPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20013>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20013) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20013)));
        }

        /// <summary>
        /// Scroll points Scroll request - paginate over all points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20013</returns>
        public async System.Threading.Tasks.Task<InlineResponse20013> ScrollPointsAsync (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20013> localVarResponse = await ScrollPointsAsyncWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Scroll points Scroll request - paginate over all points which matches given filtering condition
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to retrieve from</param>
        /// <param name="body">Pagination and filter parameters (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20013)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20013>> ScrollPointsAsyncWithHttpInfo (string collectionName, ScrollRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->ScrollPoints");

            var localVarPath = "/collections/{collection_name}/points/scroll";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ScrollPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20013>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20013) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20013)));
        }

        /// <summary>
        /// Search batch points Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20015</returns>
        public InlineResponse20015 SearchBatchPoints (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20015> localVarResponse = SearchBatchPointsWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search batch points Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20015</returns>
        public ApiResponse< InlineResponse20015 > SearchBatchPointsWithHttpInfo (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->SearchBatchPoints");

            var localVarPath = "/collections/{collection_name}/points/search/batch";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchBatchPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20015>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20015) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20015)));
        }

        /// <summary>
        /// Search batch points Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20015</returns>
        public async System.Threading.Tasks.Task<InlineResponse20015> SearchBatchPointsAsync (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20015> localVarResponse = await SearchBatchPointsAsyncWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search batch points Retrieve by batch the closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search batch request (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20015)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20015>> SearchBatchPointsAsyncWithHttpInfo (string collectionName, SearchRequestBatch body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->SearchBatchPoints");

            var localVarPath = "/collections/{collection_name}/points/search/batch";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchBatchPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20015>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20015) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20015)));
        }

        /// <summary>
        /// Search points Retrieve closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>InlineResponse20014</returns>
        public InlineResponse20014 SearchPoints (string collectionName, SearchRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20014> localVarResponse = SearchPointsWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Search points Retrieve closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse20014</returns>
        public ApiResponse< InlineResponse20014 > SearchPointsWithHttpInfo (string collectionName, SearchRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->SearchPoints");

            var localVarPath = "/collections/{collection_name}/points/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20014>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20014) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20014)));
        }

        /// <summary>
        /// Search points Retrieve closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse20014</returns>
        public async System.Threading.Tasks.Task<InlineResponse20014> SearchPointsAsync (string collectionName, SearchRequest body = null, ReadConsistency consistency = null)
        {
             ApiResponse<InlineResponse20014> localVarResponse = await SearchPointsAsyncWithHttpInfo(collectionName, body, consistency);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Search points Retrieve closest points based on vector similarity and given filtering conditions
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to search in</param>
        /// <param name="body">Search request with optional filtering (optional)</param>
        /// <param name="consistency">Define read consistency guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse20014)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse20014>> SearchPointsAsyncWithHttpInfo (string collectionName, SearchRequest body = null, ReadConsistency consistency = null)
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->SearchPoints");

            var localVarPath = "/collections/{collection_name}/points/search";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (consistency != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "consistency", consistency)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse20014>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse20014) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse20014)));
        }

        /// <summary>
        /// Set payload Set payload values for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 SetPayload (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = SetPayloadWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Set payload Set payload values for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > SetPayloadWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->SetPayload");

            var localVarPath = "/collections/{collection_name}/points/payload";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Set payload Set payload values for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> SetPayloadAsync (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = await SetPayloadAsyncWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Set payload Set payload values for points
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to set from</param>
        /// <param name="body">Set payload on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> SetPayloadAsyncWithHttpInfo (string collectionName, SetPayload body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->SetPayload");

            var localVarPath = "/collections/{collection_name}/points/payload";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SetPayload", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Upsert points Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>InlineResponse2006</returns>
        public InlineResponse2006 UpsertPoints (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = UpsertPointsWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Upsert points Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>ApiResponse of InlineResponse2006</returns>
        public ApiResponse< InlineResponse2006 > UpsertPointsWithHttpInfo (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->UpsertPoints");

            var localVarPath = "/collections/{collection_name}/points";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

        /// <summary>
        /// Upsert points Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of InlineResponse2006</returns>
        public async System.Threading.Tasks.Task<InlineResponse2006> UpsertPointsAsync (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
             ApiResponse<InlineResponse2006> localVarResponse = await UpsertPointsAsyncWithHttpInfo(collectionName, body, wait, ordering);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Upsert points Perform insert + updates on points. If point with given ID already exists - it will be overwritten.
        /// </summary>
        /// <exception cref="IO.Swagger.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="collectionName">Name of the collection to update from</param>
        /// <param name="body">Operation to perform on points (optional)</param>
        /// <param name="wait">If true, wait for changes to actually happen (optional)</param>
        /// <param name="ordering">define ordering guarantees for the operation (optional)</param>
        /// <returns>Task of ApiResponse (InlineResponse2006)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<InlineResponse2006>> UpsertPointsAsyncWithHttpInfo (string collectionName, PointInsertOperations body = null, bool? wait = null, WriteOrdering ordering = default(WriteOrdering))
        {
            // verify the required parameter 'collectionName' is set
            if (collectionName == null)
                throw new ApiException(400, "Missing required parameter 'collectionName' when calling PointsApi->UpsertPoints");

            var localVarPath = "/collections/{collection_name}/points";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (collectionName != null) localVarPathParams.Add("collection_name", this.Configuration.ApiClient.ParameterToString(collectionName)); // path parameter
            if (wait != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "wait", wait)); // query parameter
            if (ordering != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "ordering", ordering)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpsertPoints", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<InlineResponse2006>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (InlineResponse2006) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(InlineResponse2006)));
        }

    }
}
